# 문제 6. LCS (최장 공통 부분 수열)

## 문제 설명

- 두 문자열 A와 B가 주어졌을 때, 두 문자열의 **최장 공통 부분 수열(Longest Common Subsequence, LCS)**의 길이를 구하는 문제
- 부분 수열이란 원래 문자열에서 **일부 문자를 삭제해도 순서를 유지하는 문자열**

---

## 입력 예시
A = "ABCBDAB"
B = "BDCABA"

---

## 출력 예시
4

→ LCS 중 하나는 "BCBA" 또는 "BDAB"

---

## 선택 알고리즘: 동적 계획법 (DP)

---

## DP 테이블 설계

- `dp[i][j]`는 A의 i번째 문자까지와 B의 j번째 문자까지의 LCS 길이
- 테이블 크기: `(len(A)+1) x (len(B)+1)`
- 첫 행과 첫 열은 공집합 기준이므로 모두 0으로 초기화

---

## 점화식

- A[i-1] == B[j-1] 이면  
  → `dp[i][j] = dp[i-1][j-1] + 1`
- A[i-1] != B[j-1] 이면  
  → `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`

---

## 구현 코드 및 테이블 출력


```python
def lcs_length(A, B):
    n, m = len(A), len(B)  # 각각 문자열 A와 B의 길이

    # 2차원 DP 테이블 생성: (n+1) x (m+1)
    # dp[i][j]는 A의 i번째 문자까지, B의 j번째 문자까지의 LCS 길이
    dp = [[0] * (m + 1) for _ in range(n + 1)]

    # 모든 위치를 순회하면서 LCS 길이 갱신
    for i in range(1, n + 1):       # A의 문자 인덱스 (1부터 시작)
        for j in range(1, m + 1):   # B의 문자 인덱스 (1부터 시작)
            if A[i - 1] == B[j - 1]:
                # A의 (i-1)번째 문자와 B의 (j-1)번째 문자가 같다면,
                # 이전까지의 공통 부분 수열에서 1 더함
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                # 다르다면, 이전까지 비교했던 경우 중 더 긴 쪽을 선택
                # (A쪽 하나 빼고 보거나, B쪽 하나 빼고 보는 것 중 큰 값)
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    # DP 테이블 출력 (중간 확인용)
    print("LCS DP 테이블:")
    for row in dp:
        print(row)

    # 최종 결과는 오른쪽 아래 칸에 있음 → A 전체, B 전체 비교 결과
    return dp[n][m]


# 예시 실행
A = "ABCBDAB"
B = "BDCABA"
print("LCS 길이:", lcs_length(A, B))

[0, 0, 0, 0, 0, 0, 0]
[0, 0, 0, 1, 1, 1, 1]
[0, 1, 1, 1, 2, 2, 2]
[0, 1, 1, 1, 2, 2, 2]
[0, 1, 2, 2, 2, 2, 3]
[0, 1, 2, 2, 2, 3, 3]
[0, 1, 2, 2, 2, 3, 4]
[0, 1, 2, 2, 3, 3, 4]
LCS 길이: 4

